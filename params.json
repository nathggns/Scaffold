{"note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":"Light Weight PHP API Framework","body":"Scaffold\r\n========\r\n\r\nLightweight PHP API Framework\r\n\r\n**Note:** This is not a usable state yet.\r\n\r\nRequirements\r\n============\r\n\r\n - PHP **5.4+**\r\n\r\nFeatures\r\n========\r\n\r\nScaffold, despite it's ultimate speed and ease of use, is just jam-packed with features.\r\n\r\n## Autoloader\r\n\r\nAt the heart of Scaffold, is it's Autoloader. No longer do you need to care about loading different classes for use in your application. But that doesn't mean your application will be slowed down with useless resources it doesn't need: **Scaffold operates on a *there when you need it, out of the way when you don't* basis**. \r\n\r\nIn order to use a class, you just use it:\r\n\r\n```php\r\n<?php\r\n$validator = new Validate();\r\n$validator->set('name', 'not_empty');\r\n$validator->test($data);\r\n```\r\n\r\nBut that doesn't mean that's the only way to do things, Scaffold provides a method for manually loading a class.\r\n\r\n```php\r\n<?php\r\nAutoload::load('Validate');\r\nAutoload::load('Router');\r\n// etc\r\n```\r\n\r\n## Validator\r\n\r\nYou saw a little sneak peek at our validator in the previous section. Scaffold's validator is about as simple as it gets, while still remaining extremely powerful.\r\n\r\n### Example\r\n\r\n```php\r\n<?php\r\n$validator = new Validate([\r\n    'name' => ['not_empty', 'alphanumeric'],\r\n    'email' => ['not_empty', 'email']\r\n]);\r\n$validator->set('password', 'not_empty');\r\n\r\n$validator->test(['name' => 'Bob', 'email' => 'scaffold.is.awesome@gmail.com', 'password' => 'scaffold']);\r\n// Returns true\r\n\r\n$validator->test(['name' => '', 'email' => 'scaffold']);\r\n// Raises ExceptionValidate\r\n```\r\n\r\n### Global Rules\r\n\r\nThere are a few ways of setting global rules, but under the hood, they all equal the same thing: The field name equaling null.\r\n\r\n```php\r\n<?php\r\n// All of these are global rules\r\n$validator = new Validate('not_empty');\r\n$validator->set('not_empty');\r\n$validator->set(['not_empty']);\r\n$validator->set(null, 'not_empty');\r\n$validator->set([null => 'not_empty']);\r\n```\r\n\r\n### List of Rules\r\n\r\n#### empty\r\n\r\n`empty` tests for if a value is `'' || false`. In addition, it will also return true if you haven't passed a value for this rule. However, you're unlikely to use this rule yourself. You are more likely to use it in conjuction with the `not` modifier, to make `not_empty`. This can be used to make required fields.\r\n\r\n#### email\r\n\r\n`email` uses PHP's built in email checking (`filter_var($val, FILTER_VALIDATE_EMAIL)`) systems in order to check if the value is a valid email address.\r\n\r\n#### alphanumeric\r\n\r\n`alphanumeric` allows any character in the range `[a-zA-Z0-9]`. And character outside of that will make the rest fail.\r\n\r\n#### Others\r\n\r\nThere are a few other rules that are used *behind the scenes*. These are `regex`, `is_regex` and `equal`. There is no way that you can use `is_regex` in your checks, however, you can use `regex` and `equal`.\r\n\r\nIf the rule name is a valid regex pattern, and doesn't match an existing rule name, then Validate will run a test for the value against that pattern. If it is not, then Validate will simply check if the value matches the rule name.\r\n\r\n### List of Modifiers\r\n\r\nTo use a modifier, you just prepend it's name, followed by an `_` to the rule name.\r\n\r\n#### not\r\n\r\n`not` is simple modifier, it simply reverses the output of the rule.\r\n\r\nTake `not_empty` for example. Run `empty` against `''`, and you get `true`. Run `not_empty` against `''`, and you get `false`.\r\n\r\n### ExceptionValidate\r\n\r\nWhen a validation error occours, `Validate` throws an `ExceptionValidate` exception. This is almost exactly the same as a normal `Exception`, but you can access the exception errors as `$e->errors`. This array contains all the information you could possibly need: Which tests failed, what tests were ran on what, etc. The following is one of the errors from the previous example.\r\n\r\n    array(4) {\r\n      [\"name\"]=>\r\n        string(4) \"name\"\r\n      [\"tests\"]=>\r\n        array(2) {\r\n          [0]=>\r\n            string(9) \"not_empty\"\r\n          [1]=>\r\n            string(12) \"alphanumeric\"\r\n        }\r\n      [\"value\"]=>\r\n        string(0) \"\"\r\n      [\"errors\"]=>\r\n        array(2) {\r\n          [0]=>\r\n            array(4) {\r\n              [\"result\"]=>\r\n                bool(false)\r\n              [\"rule\"]=>\r\n                string(9) \"not_empty\"\r\n              [\"value\"]=>\r\n                string(0) \"\"\r\n              [\"type\"]=>\r\n                int(1)\r\n            }\r\n          [1]=>\r\n            array(4) {\r\n              [\"result\"]=>\r\n                bool(false)\r\n              [\"rule\"]=>\r\n                string(12) \"alphanumeric\"\r\n              [\"value\"]=>\r\n                string(0) \"\"\r\n              [\"type\"]=>\r\n                int(1)\r\n            }\r\n      }\r\n    }\r\n    \r\n    \r\nThe bit we care about is the errors property, which should be self explanatory, besides `type` and `result`.\r\n\r\n`result` is the raw response from the `check` function called, after all the `modifier` functions are called. Check functions are your standard `email`, `alphanumeric` checks and `modifiers` are the bits prepended with an `_`, the only current one being `not`.\r\n\r\n`type` represents the type of validation error that has occured. This can either be `Validate::TEST_FAILED`, for if a test actually fails, or `Validate::INVALID_DATA` for if you give test a numeric array instead of an associative array. ","name":"Scaffold","google":"UA-35201099-1"}